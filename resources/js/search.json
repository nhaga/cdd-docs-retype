[[{"l":"cddl-codegen","p":["Experimental library for generating rust code for CBOR (de) serialization from CDDL specs."]},{"l":"Purpose","p":["Instead of hand-writing code for CBOR parsing and writing tests to make sure it matches your CDDL spec, it's much faster to just generate the code from the spec! It will save time and make it easier to keep all your code in sync with any changes to your specification.","You can learn more about CDDL here"]}],[{"i":"installation--getting-started","l":"Installation & Getting Started"},{"l":"Install"},{"l":"Run Example","p":["To run execute cargo run -- --input=input.cddl --output=EXPORT_DIR to read ./input.cddl and produce output code in ./EXPORT_DIR/."]},{"l":"Build"}],[{"l":"Command line flags","p":["(The rust code doesn't need this as you can directly use the Serialize/ Deserialize traits on them.)","Derives serde::Serialize/serde::Deserialize for types to allow to/from JSON","Example:","For a single file:","Generates a npm package.json along with build scripts (some of these scripts require --json-serde-derives/--json-schema-export to work).","Generates to_cbor_bytes()/ from_cbor_bytes() methods on all WASM objects. On by default.","If a directory is specified e.g. --input=some_dir then it will read all files in this directory (non-recursively). The output format changes here. If there's a lib.cddl the types contained there are the standard output, and any other file e.g. foo.cddl will have its own module foo/mod.rs with its own foo/serialization.rs, etc.","Possible values: true, false","Possible values: true, false Default: false","Possible values: true, false Default: true","Preserves CBOR encoding upon deserialization e.g. definite vs indefinite, map ordering. For each module this will also create a cbor_encodings.rs file to potentially store any structs for storing these encodings. This option is useful if you need to preserve the deserialized format for round-tripping (e.g. hashes) or if you want to modify the format to conincide with a specific tool for hashing.","Specifies the input CDDL file(s).","Specifies the output directory.","Specify the rust crate name for the output library. The wasm crate will have -wasm appended.","Tags types with sonSchema derives and generates a crate (in wasm/json-gen) to export them. This requires --json-serde-derives.","Used primarily with --preserve-encodings to provide a way to override the specific deserialization format and to instead output canonical CBOR. This will have Serialize's trait have an extra to_canonical_cbor_bytes() method. Likewise the wasm wrappers (with --to-from-bytes-methods) will contain one too.","Whether to output a wasm crate. On by default."]}],[{"l":"Current capacities"},{"l":"Types","p":["Array groups - foo = [uint, tstr, 0, bytes]","Array values - [uint]","cbor in bytes - foo_bytes = bytes .cbor foo","CDDL Generics - fooT = [T], bar = foouint","default values - ? key : uint .default 0","Deserialization for almost all supported types (see limitations section).","Embedding groups in other groups - foo = (0, bstr) bar = [uint, foo, foo]","Fixed values - null, nil, true, false","Group choices - foo = [ 0, uint // 1, tstr, uint // tstr }","Identifiers and fields are also changed to rust style. ie foo_bar = { Field-Name: text } gets converted into struct FooBar { field_name: String }","Inline groups at root level - foo = ( a: uint, b: uint)","Length bounds - foo = bytes .size (0..32)","Map groups (both struct-type and table-type) - foo = { a: uint, b: tstr } or bar = { * uint = tstr }","Optional fields - foo = { ? 0 : bytes }","Primitives - bytes, bstr, tstr, text, uint, nint","Serialization for all supported types.","Support for the CDDL standard prelude (using raw CDDL from the RFC) - biguint, etc","Table types as members - foo = ( x: { * a = b } )","Tagged major types - rational = #6.30([ numerator : uint, denominator : uint])","Type aliases - foo = bar","Type choices - foo = uint / tstr","We generate getters for all fields, and setters for optional fields. Mandatory fields are set via the generated constructor. All wasm-facing functions are set to take references for non-primitives and clone when needed. Returns are also cloned. This helps make usage from wasm more memory safe."]},{"l":"Group choices","p":["Group choices are handled as an enum with each choice being a variant. This enum is then wrapped around a wasm-exposed struct as wasm_bindgen does not support rust enums with members/values. Group choices that have only a single non-fixed-value field use just that field as the enum variant, otherwise we create a GroupN for the Nth variant enum with the fields of that group choice. Any fixed values are resolved purely in serialization code, so 0, hello, uint puts the uint in the enum variant directly instead of creating a new struct."]},{"l":"Type choices","p":["Type choices are handled via enums as well with the name defaulting to AOrBOrC for A / B / C when inlined as a field/etc, and will take on the type identifier if provided ie foo = A / B / C would be Foo. Any field that is T / null is transformed as a special case into OptionT rather than creating a TOrNull enum.","A special case for this is when all types are fixed values e.g. foo = 0 / 1 / hello, in which case we generate a special c-style enum in the rust. This will have wasm_bindgen tags so it can be directly used in the wasm crate. Encoding variables (for --preserve-encodings=true) are stored where the enum is used like with other primitives."]}],[{"l":"Output format","p":["Inside of the output directly the tool always produces a rust/ directory (including Cargo.toml, etc).","Unless we pass in --wasm=false the tool also generates a corresponding wasm/ directory.","The default format for rust/ is to have a lib.rs containing the structs and serialization.rs containing their (de)serialization implementations/corresponding types.","The wasm/ directory is full of wasm_bindgen-annotated wrappers all in lib.rs for the corresponding rust-use-only structs in rust/ and can be compiled for WASM builds by running wasm-pack build on it.","Example Output","The output format can change slightly depending on certain command line flags:","--wasm=false","--preserve-encodings=true","--json-schema-export true","--package-json true --json-schema-export true"]}],[{"l":"Wasm Differences","p":["In the wasm crate we can't always go one to one with the rust crate. Here are some differences/extra types in the WASM create. AsRef From and Into are implemented to go between the rust and wasm crate types to help."]},{"l":"Heterogeneous Arrays","p":["wasm_bindgen cannot expose doubly-nested types like VecVecT which can be a limitation if T was a non-byte primtive. Any array of non-primitives such as [foo] will generate another type called FooList which supports all basic array operations. This lets us get around the wasm_bindgen limitation (without implementing cross-boundary traits which could be inefficient/tedious/complicated). This array wrapper implements len() - self, get(usize) - T and add(T)."]},{"l":"Tables","p":["Map literals also generate a type for them with len() - usize and insert(K, V) - OptionV. The table type will have a MapKeyToValue name for whichever Key and Value types it's exposed as if it's anonymously inlined a as a member, or will take on the identifier if it's a named one."]},{"l":"Enums","p":["Both type/group choices generate rust-style enums. On the wasm side we can't do that so we directly wrap the rust type, and then provide a FooKind c-style enum for each rust enum Foo just for checking which variant it is."]}],[{"l":"Comment DSL","p":["We have a comment DSL to help annotate the output code beyond what is possible just with CDDL."]},{"i":"name","l":"@name","p":["For example in an array-encoded group you can give explicit names just by the keys e.g.:","but with map-encoded structs the keys are stored and for things like integer keys this isn't very helpful e.g.:","we would end up with two fields: key_0 and key_1. We can instead end up with fields named inputs and outputs by doing:","Note: the parsing can be finicky. For struct fields you must put the comment AFTER the comma, and the comma must exist even for the last field in a struct.","It is also possible to use @name with type choices:","and also for group choices:"]},{"i":"newtype","l":"@newtype","p":["With code like foo = uint this creates an alias e.g. pub type Foo = u64; in rust. When we use foo = uint ; @newtype it instead creates a pub struct Foo(u64);."]},{"i":"no_alias","l":"@no_alias","p":["This would normally result in:","but if we use @no_alias it skips generating an alias and uses it directly e.g.:","to"]},{"l":"CDDL_CODEGEN_EXTERN_TYPE","p":["While not as a comment, this allows you to compose in hand-written structs into a cddl spec.","This will treat Foo as a type that will exist and that has implemented the Serialize and Deserialize traits, so the (de)serialization logic in Bar here will call Foo::serialize() and Foo::deserialize(). This can also be useful when you have a spec that is either very awkward to use (so you hand-write or hand-modify after generation) in some type so you don't generate those types and instead manually merge those hand-written/hand-modified structs back in to the code afterwards. This saves you from having to manually remove all code that is generated regarding Foo first before merging in your own."]}],[{"i":"#","p":["import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';"]},{"l":"Examples"},{"l":"Aliases","p":["Type alias","Create a newtype around another type instead of an alias","or don't generate either and directly use the aliased type instead","pay attention to the @name comment placement as it can be finicky"]},{"i":"sizelength-requirements-on-primitives","l":"Size/length requirements on primitives","p":["Integer restrictions that map to rust types are directly translated","u8 in rust","u16 in rust","u32, etc...","One can also limit strings (text or bytes) to a specific length","or to a range e.g. between 10 and 20 bytes"]},{"l":"Array struct","p":["All primitives are supported, e.g. uint, nint and int supported. int generates special code as no rust equivalent. Unnamed array fields try to derive name from type if possible:","Text/bytes is also supported, or one can give them an explicit name:","As well as floats (without --preserve-encodings=true)"]},{"i":"mark-as-externally-defined","l":"Mark as externally defined.","p":["user has to insert/import code for this type after generation"]},{"l":"Map struct","p":["Map struct + tagged fields + .cbor + optional fields + constants + .default","Fields can be tagged and this remains a serialization detail (hidden from API)","They can also be encoded as CBOR bytes which remains a serialization detail (hidden from API). This can be combined with tags as well i.e. #6.42(bytes .cbor extern_foo)","Optional field (generates as OptionT)","Type choice with null will result in OptionT too for the API. Also, you can give explicit names that differ from the key value for maps like this:","Optional string constant (no field generated)","Integer constant (no field generated)","This will not be an optional field in rust, as when it is not present, it will be set to 0"]},{"l":"Basic groups","p":["Basic groups are supported and have their own type","Basic groups are fully supported in array groups","They can be put into an array struct directly i.e. embed their fields into outer, which is only a serialization detail. this field will be of type Basic; or one can embed them into a repeatable homogeneous array","Basic groups can be embeded in maps, BUT deserialization will not be generated due to technical limitations","A single basic group cannot be put into both a map and an array group for serialization which is why we had to define a separate one other_basic instead of just using basic","One can directly define homogeneous maps as fields (or define them at top-level). Also define homogenous arrays as fields (or define them at top-level)"]},{"l":"Type Choices","p":["If a type choice only has constants it will generate as a c-style enum (directly wasm-exposable)","If there is only one non-constant field in the inlined group then that will be inlined in the enum, but if there are multiple then a new struct will be generated from this variant"]}]]